package de.rwth.ti.db;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

/**
 * This class handles the database or persistent storage access
 * 
 * @author tcuje
 * 
 */
public class StorageHandler {

	private SQLiteDatabase db;
	private Storage storage;

	public StorageHandler(Context context) {
		storage = new Storage(context);
	}

	public void onStart() throws SQLException {
		db = storage.getWritableDatabase();
	}

	public void onStop() {
		storage.close();
	}

	/**
	 * Add the access point to measurement database
	 * 
	 * @return The id for the new access point
	 */
	public long addAp(Scan scan, String bssid, int level, int freq,
			String ssid, String props) {
		ContentValues values = new ContentValues();
		values.put(AccessPoint.COLUMN_SCAN, scan.getId());
		values.put(AccessPoint.COLUMN_BSSID, bssid);
		values.put(AccessPoint.COLUMN_LEVEL, level);
		values.put(AccessPoint.COLUMN_FREQ, freq);
		values.put(AccessPoint.COLUMN_SSID, ssid);
		values.put(AccessPoint.COLUMN_PROPS, props);
		long insertId = db.insert(AccessPoint.TABLE_NAME, null, values);
		return insertId;
	}

	public AccessPoint cursorToAp(Cursor cursor) {
		AccessPoint ap = new AccessPoint();
		ap.setId(cursor.getLong(0));
		ap.setScan(cursor.getLong(1));
		ap.setBssid(cursor.getString(2));
		ap.setLevel(cursor.getInt(3));
		ap.setFreq(cursor.getInt(4));
		ap.setSsid(cursor.getString(5));
		ap.setProps(cursor.getString(6));
		return ap;
	}

	/**
	 * 
	 * @param cpid
	 *            checkpoint id
	 * @param time
	 *            timestamp in seconds since 1.1.1970
	 * @param compass
	 *            azimut value
	 * @return Returns the readonly scan object
	 */
	public Scan addScan(long cpid, long time, long compass) {
		ContentValues values = new ContentValues();
		values.put(Scan.COLUMN_CPID, cpid);
		values.put(Scan.COLUMN_TIME, time);
		values.put(Scan.COLUMN_COMPASS, compass);
		long insertId = db.insert(Scan.TABLE_NAME, null, values);
		Cursor cursor = db.query(Scan.TABLE_NAME, Scan.ALL_COLUMNS,
				Scan.COLUMN_ID + " = " + insertId, null, null, null, null);
		cursor.moveToFirst();
		Scan scan = cursorToScan(cursor);
		cursor.close();
		return scan;
	}

	public Scan cursorToScan(Cursor cursor) {
		Scan scan = new Scan();
		scan.setId(cursor.getLong(0));
		scan.setCpid(cursor.getLong(1));
		scan.setTime(cursor.getLong(2));
		scan.setCompass(cursor.getLong(3));
		return scan;
	}

	/**
	 * 
	 * @param mapid
	 *            The id of the map where the checkpoint is placed
	 * @param x
	 *            The x coordinate for this checkpoint on the referenced map
	 * @param y
	 *            The y coordinate for this checkpoint on the referenced map
	 * @return Returns the id for the newly added checkpoint
	 */
	public long addCheckpoint(long mapid, double x, double y) {
		ContentValues values = new ContentValues();
		values.put(Checkpoint.COLUMN_MID, mapid);
		values.put(Checkpoint.COLUMN_POS_X, x);
		values.put(Checkpoint.COLUMN_POS_Y, y);
		long insertId = db.insert(Checkpoint.TABLE_NAME, null, values);
		return insertId;
	}

	public long countScans() {
		Cursor cursor = db.rawQuery("SELECT COUNT(*) FROM " + Scan.TABLE_NAME,
				null);
		cursor.moveToFirst();
		long result = cursor.getLong(0);
		cursor.close();
		return result;
	}

	public long countAccessPoints() {
		Cursor cursor = db.rawQuery("SELECT COUNT (*) FROM "
				+ AccessPoint.TABLE_NAME, null);
		cursor.moveToFirst();
		long result = cursor.getLong(0);
		cursor.close();
		return result;
	}
}
